
RocketMQ版本 v4.9.3。

RocketMQ支持3种消息发送方式：

- 同步（sync ）：发送者发送消息时，同步等待，直到消息服务器返回发送结果。
- 异步（async）：发送者先指定回调函数，发送完消息后，立即返回，消息发送者线程不阻塞，直到运行结束，消息发送成功或失败的回调任务在一个新的线程中执行。
- 单向（oneway）：发送者发送消息后，直接返回，不等待消息服务器的结果，也不注册回调函数，简单地说，就是只管发，不在乎消息是否成功存储在消息服务器上。

# 1 RocketMQ 消息

RocketMQ 消息封装类是 `org.apache.rocketmq.common.message.Message`:

```java
public class Message implements Serializable {
    private static final long serialVersionUID = 8445773977080406428L;

    //主题
    private String topic;

    //消息 Flag(RocketMQ 不做处理）
    private int flag;

    //扩展属性，主要包含下面几个：
    //tag：消息TAG，用于消息过滤。
    //keys: Message索引键，多个用空格隔开，RocketMQ可以根据这些key快速检索到消息。
    //waitStoreMsgOK：消息发送时是否等消息存储完成后再返回。
    //delayTimeLevel：消息延迟级别，用于定时消息或消息重试。
    private Map<String, String> properties;

    //消息体
    private byte[] body;
    
    //事务id
    private String transactionId;
}
```

# 2 生产者启动流程

消息生产者的代码在client模块中，相对于RocketMQ来说，它就是客户端，在应用系统中初始化生产者的一个实例即可使用它来发消息。

# 2.1  DefaultMQProducer 消息发送者

## 2.1.1 DefaultMQProducer类

DefaultMQProducer是默认的生产者实现类，继承了ClientConfig类，实现MQProducer(继承了MQAdmin接口)接口:

```java
public class DefaultMQProducer extends ClientConfig implements MQProducer {

    //包装这个类中几乎所有方法的内部实现
    protected final transient DefaultMQProducerImpl defaultMQProducerImpl;

    private final InternalLogger log = ClientLogger.getLog();

    //返回码
    private final Set<Integer> retryResponseCodes = new CopyOnWriteArraySet<Integer>(Arrays.asList(
            ResponseCode.TOPIC_NOT_EXIST,
            ResponseCode.SERVICE_NOT_AVAILABLE,
            ResponseCode.SYSTEM_ERROR,
            ResponseCode.NO_PERMISSION,
            ResponseCode.NO_BUYER_ID,
            ResponseCode.NOT_IN_CURRENT_UNIT
    ));

    //生产者组，聚合了完全相同角色的所有生产者实例
    //对于非事务性消息，只要它在每个进程中是唯一的就没关系
    private String producerGroup;

    //默认 topicKey
    private String createTopicKey = TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC;

    //主题在每一个 Broker 的默认队列数量
    private volatile int defaultTopicQueueNums = 4;

    //消息发送超时时间，默认 3s
    private int sendMsgTimeout = 3000;

    //消息体超过该值则启用压缩，默认 4K
    private int compressMsgBodyOverHowmuch = 1024 * 4;

    //同步方式发送消息重试次数，默认为2 ，总共执行 3 次
    //可能导致消息重复，需要开发人员自行解决。
    private int retryTimesWhenSendFailed = 2;

    //异步方式发送消息重试次数，默认为 2
    //可能会导致消息重复，需要开发人员自行解决。
    private int retryTimesWhenSendAsyncFailed = 2;

    //消息重试时选择另外一个Broker时，是否不等待存储结果就返回，默认为false
    private boolean retryAnotherBrokerWhenNotStoreOK = false;

    //允许发送的最大消息长度，默认为4M，该值最大为2^32-1
    private int maxMessageSize = 1024 * 1024 * 4;

    //异步传输数据的接口
    private TraceDispatcher traceDispatcher = null;
}
```

```java
//客户端通用属性
public class ClientConfig {

    public static final String SEND_MESSAGE_WITH_VIP_CHANNEL_PROPERTY = "com.rocketmq.sendMessageWithVIPChannel";

    private String namesrvAddr = NameServerAddressUtils.getNameServerAddresses();
    private String clientIP = RemotingUtil.getLocalAddress();
    private String instanceName = System.getProperty("rocketmq.client.name", "DEFAULT");
    private int clientCallbackExecutorThreads = Runtime.getRuntime().availableProcessors();
    protected String namespace;
    private boolean namespaceInitialized = false;
    protected AccessChannel accessChannel = AccessChannel.LOCAL;

    //拉取主题信息的间隔
    private int pollNameServerInterval = 1000 * 30;

    //向broker发送心跳的间隔，ms
    private int heartbeatBrokerInterval = 1000 * 30;

    /**
     * Offset persistent interval for consumer
     */
    private int persistConsumerOffsetInterval = 1000 * 5;

    private long pullTimeDelayMillsWhenException = 1000;

    private boolean unitMode = false;

    private String unitName;
    
    private boolean vipChannelEnabled = Boolean.parseBoolean(System.getProperty(SEND_MESSAGE_WITH_VIP_CHANNEL_PROPERTY, "false"));

    private boolean useTLS = TlsSystemConfig.tlsEnable;

    private int mqClientApiTimeout = 3 * 1000;

    private LanguageCode language = LanguageCode.JAVA;
}
```

## 2.1.2 核心方法

|\<interface\> MQAdmin|备注|
|--------------|----|
|void createTopic(String key, String newTopic, int queueNum)|创建主题|
|long searchOffset(final MessageQueue mq, final long timestamp)|根据时间戳从队列中查找其偏移量|
|long maxOffset(final MessageQueue mq)|查找该消息队列中最大的物理偏移量|
|long minOffset(final MessageQueue mq)|查找该消息队列中最小物理偏移量|
|long earliestMsgStoreTime(final MessageQueue mq)|获取消息存储的最早时间|
|MessageExt viewMessage(final String offsetMsgld)|根据消息偏移量查找消息|
|QueryResult queryMessage(String topic, String key, int maxNum, Iong begin, long end)|根据条件查询消息|
|MessageExt viewMessage(String topic, String msgld)|根据主题与消息 ID 查找消息|


|\<interface\> MQProducer|备注|
|--------------|----|
|List fetchPublishMessageQueues{final String topic)|查找该主题下所有的消息队列|
|SendResult send{Message msg)|同步发送消息，具体发送到主题中的哪个消息队列由负载算法决定|
|void send(final Message msg, final MessageQueue mq, final SendCallback
sendCallback)|异步方式发送消息，发送到指定消息队列|
|void sendOneway(final Message msg, final MessageQueue mq)|单向消息发送，就是不在乎发送结果，消息发送出去后该方法立即返回|
|TransactionSendResult sendMessagelnTransaction(Message msg, LocalTransactionExecuter tranExecuter, Object arg)||
|void start()|启动发送者|
|void shutdown()|关闭发送者|

## 2.2 消息生产者启动流程

### 2.2.1 DefaultMQProducerlmpl 的 start 方法

我们可以从 DefaultMQProducerlmpl的start方法来查看，消息生产者是如何启动的。

```java
//org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#start(boolean)
public void start(final boolean startFactory) throws MQClientException {
        switch (this.serviceState) {
            case CREATE_JUST:

                //Step 1:
                //状态修改为启动失败？
                this.serviceState = ServiceState.START_FAILED;
                //检查 producerGroup 是否合法
                this.checkConfig();
                //将生产者的 instanceName 改为进程 ID
                if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) {
                    this.defaultMQProducer.changeInstanceNameToPID();
                }

                //Step 2:
                //通过 MQClientManager 创建 MQClientlnstance 实例
                this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQProducer, rpcHook);

                //Step 3:
                //向 MQClientlnstance 注册，将当前生产者加入到 MQClientlnstance 管理 中，方便后续调用网络请求、进行心跳检测等
                boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);
                if (!registerOK) {
                    this.serviceState = ServiceState.CREATE_JUST;
                    throw new MQClientException("The producer group[" + this.defaultMQProducer.getProducerGroup()
                            + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                            null);
                }

                this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());

                //Step 4:
                //启动 MQClientlnstance，如果 MQClientlnstance 已经启动 ，则本次启动不会真正执行。
                if (startFactory) {
                    mQClientFactory.start();
                }

                log.info("the producer [{}] start OK. sendMessageWithVIPChannel={}", this.defaultMQProducer.getProducerGroup(),
                        this.defaultMQProducer.isSendMessageWithVIPChannel());
                this.serviceState = ServiceState.RUNNING;
                break;
            case RUNNING:
            case START_FAILED:
            case SHUTDOWN_ALREADY:
                throw new MQClientException("The producer service state not OK, maybe started once, "
                        + this.serviceState
                        + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),
                        null);
            default:
                break;
        }

        this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();

        RequestFutureHolder.getInstance().startScheduledTask(this);

    }
```

### 2.2.2 MQClientManager 类

MQClientManager是个单例类，采用饿汉模式创建。

作用：提供 MQClientInstance 实例，并且根据 clientId 复用 MQClientInstance 实例。

```java
public class MQClientManager {
    private final static InternalLogger log = ClientLogger.getLog();

    //静态实例
    private static MQClientManager instance = new MQClientManager();
    private AtomicInteger factoryIndexGenerator = new AtomicInteger();

    //存储MQClientInstance示例
    private ConcurrentMap<String/* clientId */, MQClientInstance> factoryTable =
            new ConcurrentHashMap<String, MQClientInstance>();

    public MQClientInstance getOrCreateMQClientInstance(final ClientConfig clientConfig) {
        return getOrCreateMQClientInstance(clientConfig, null);
    }


    // 缓存表 ConcurrentMap<String /＊Clientld*/，MQClientinstance＞ factoryTable，同一个 clientld 只会创建一个 MQClientinstance。
    public MQClientInstance getOrCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) {
        String clientId = clientConfig.buildMQClientId();
        MQClientInstance instance = this.factoryTable.get(clientId);
        if (null == instance) {
            instance =
                    new MQClientInstance(clientConfig.cloneClientConfig(),
                            this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);
            MQClientInstance prev = this.factoryTable.putIfAbsent(clientId, instance);
            if (prev != null) {
                instance = prev;
                log.warn("Returned Previous MQClientInstance for clientId:[{}]", clientId);
            } else {
                log.info("Created new MQClientInstance for clientId:[{}]", clientId);
            }
        }

        return instance;
    }

}

```

### 2.2.3 MQClientInstance 类

MQClientInstance 网络通信的工具类，Consumer 和 Producer 里都含有这个类。

既然MQClientInstance实现的是底层通信功能和获取并保存元数据的功能，就没必要每个Consumer或Producer都创建一个对象，一个MQClientInstance对象可以被多个Consumer或Producer公用。RocketMQ通过一个工厂类达到共用MQClientInstance的目的。

作用：

（1）与 NameServer 通信进行心跳维持、根据 Topic 获取 Broker 地址。

（2）与 Broker 通信进行收发消息、ReBalance。

```java
public class MQClientInstance {
    private final static long LOCK_TIMEOUT_MILLIS = 3000;
    private final InternalLogger log = ClientLogger.getLog();

    //客户端的配置
    private final ClientConfig clientConfig;

    private final int instanceIndex;
    private final String clientId;
    private final long bootTimestamp = System.currentTimeMillis();

    //用来缓存Group和生产者的对应关系
    private final ConcurrentMap<String/* group */, MQProducerInner> producerTable = new ConcurrentHashMap<String, MQProducerInner>();

    //用来缓存Group和消费者的对应关系
    private final ConcurrentMap<String/* group */, MQConsumerInner> consumerTable = new ConcurrentHashMap<String, MQConsumerInner>();

    //用来缓存Group和管理员的对应关系
    private final ConcurrentMap<String/* group */, MQAdminExtInner> adminExtTable = new ConcurrentHashMap<String, MQAdminExtInner>();

    //Netty客户端配置
    private final NettyClientConfig nettyClientConfig;

    private final MQClientAPIImpl mQClientAPIImpl;
    private final MQAdminImpl mQAdminImpl;

    //对Topic信息的缓存
    private final ConcurrentMap<String/* Topic */, TopicRouteData> topicRouteTable = new ConcurrentHashMap<String, TopicRouteData>();

    //加锁，NameServer上的注册表
    // updateTopicRouteInfoFromNameServer(java.lang.String, boolean, org.apache.rocketmq.client.producer.DefaultMQProducer)
    private final Lock lockNamesrv = new ReentrantLock();

    //加锁，心跳检测机制
    //sendHeartbeatToAllBrokerWithLock()
    private final Lock lockHeartbeat = new ReentrantLock();

    //对于集群中的Broker地址进行缓存
    private final ConcurrentMap<String/* Broker Name */, HashMap<Long/* brokerId */, String/* address */>> brokerAddrTable =
            new ConcurrentHashMap<String, HashMap<Long, String>>();

    //对于集群中Broker的版本信息进行缓存
    private final ConcurrentMap<String/* Broker Name */, HashMap<String/* address */, Integer>> brokerVersionTable =
            new ConcurrentHashMap<String, HashMap<String, Integer>>();

    private final ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            return new Thread(r, "MQClientFactoryScheduledThread");
        }
    });
    private final ClientRemotingProcessor clientRemotingProcessor;
    private final PullMessageService pullMessageService;
    private final RebalanceService rebalanceService;
    private final DefaultMQProducer defaultMQProducer;
    private final ConsumerStatsManager consumerStatsManager;
    private final AtomicLong sendHeartbeatTimesTotal = new AtomicLong(0);
    private ServiceState serviceState = ServiceState.CREATE_JUST;
    private Random random = new Random();
}
```

start 方法了解该类的功能：该类首先从 NameServer 获取并保存各种配置信息，比如 Topic 的 Route 信息。同时 MQClientInstance 还会通过 MQClientAPIImpl 类实现消息的收发，也就是从 Broker 获取消息或者发送消息到Broker。

```java
public void start() throws MQClientException {

    synchronized (this) {
        switch (this.serviceState) {
            case CREATE_JUST:
                this.serviceState = ServiceState.START_FAILED;

                // If not specified, looking address from name server
                if (null == this.clientConfig.getNamesrvAddr()) {
                    this.mQClientAPIImpl.fetchNameServerAddr();
                }

                // NettyRemotingClient的start()方法，这个方法中先是创建了Netty客户端，然后调用了两个定时执行的任务
                // 两个任务一个是删除过期的请求，一个是将没有连接响应的nameServer断开连接
                this.mQClientAPIImpl.start();

                // 开启如下定时任务：
                // 2分钟更新一次nameServer的地址
                // 30秒更新一次topic的路由信息
                // 30秒对Broker发送一次心跳检测，并将下线的broker删除
                // 5秒持久化一次consumer的offset
                // 1分钟调整一次线程池，这个定时任务其实什么都没有执行。
                this.startScheduledTask();

                // 调用 PullMessageService 的 run()方法，里面主要是调用了 DefaultMQPushConsumerImpl.pullMessage方法
                this.pullMessageService.start();

                // 开启负载均衡服务
                this.rebalanceService.start();

                // 开启消息发送服务
                this.defaultMQProducer.getDefaultMQProducerImpl().start(false);

                log.info("the client factory [{}] start OK", this.clientId);
                this.serviceState = ServiceState.RUNNING;
                break;
            case START_FAILED:
                throw new MQClientException("The Factory object[" + this.getClientId() + "] has been created before, and failed.", null);
            default:
                break;
        }
    }
}
```

## 2.3 消息发送基本流程

主要的步骤：验证消息、查找路由、消息发送（包含异常处理机制）。

默认消息发送以同步方式发送，默认超时时间为3s。

```java
public SendResult send(Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
    return send(msg, this.defaultMQProducer.getSendMsgTimeout());
}

public SendResult send(Message msg, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
    return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);
}

private SendResult sendDefaultImpl(
            Message msg,
            final CommunicationMode communicationMode,
            final SendCallback sendCallback,
            final long timeout
    ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
        
    //1 验证生产者处于运行状态
    this.makeSureStateOK();

    //2 验证消息是否符合相应的规范
    Validators.checkMessage(msg, this.defaultMQProducer);

    final long invokeID = random.nextLong();
    long beginTimestampFirst = System.currentTimeMillis();
    long beginTimestampPrev = beginTimestampFirst;
    long endTimestamp = beginTimestampFirst;

    //3 查找主题路由信息
    TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());

    //4 消息发送
    if (topicPublishInfo != null && topicPublishInfo.ok()) {
        boolean callTimeout = false;
        MessageQueue mq = null;
        Exception exception = null;
        SendResult sendResult = null;

        //4.1 同步方式重试次数
        int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;
        int times = 0;
        String[] brokersSent = new String[timesTotal];

        for (; times < timesTotal; times++) {

            //4.2 上一次选择的执行发送消息失败的 Broker
            String lastBrokerName = null == mq ? null : mq.getBrokerName();
            MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);
            if (mqSelected != null) {
                mq = mqSelected;
                brokersSent[times] = mq.getBrokerName();
                try {
                    beginTimestampPrev = System.currentTimeMillis();
                    if (times > 0) {
                        //Reset topic with namespace during resend.
                        msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic()));
                    }
                    long costTime = beginTimestampPrev - beginTimestampFirst;                        if (timeout < costTime) {
                        callTimeout = true;
                        break;
                    }

                    //4.2 消息发送
                    sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);

                    endTimestamp = System.currentTimeMillis();

                    //4.3 更新 mq.getBrokerName() 的规避时长
                    this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);
                    switch (communicationMode) {
                        case ASYNC:
                            return null;
                        case ONEWAY:
                            return null;
                        case SYNC:
                            if (sendResult.getSendStatus() != SendStatus.SEND_OK) {
                                if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) {
                                    continue;
                                }
                            }

                            return sendResult;
                        default:
                            break;
                    }

                    //4.4 异常处理。如果发送过程中抛出了异常，调用 DefaultMQProducerlmpl#updateFaultItem，更新错误项规避时长
                } catch (RemotingException e) {
                    endTimestamp = System.currentTimeMillis();
                    this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);
                    log.warn(String.format("sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s", invokeID, endTimestamp - beginTimestampPrev, mq), e);
                    log.warn(msg.toString());
                    exception = e;
                    continue;
                } catch (MQClientException e) {
                    endTimestamp = System.currentTimeMillis();
                    this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);
                    log.warn(String.format("sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s", invokeID, endTimestamp - beginTimestampPrev, mq), e);
                    log.warn(msg.toString());
                    exception = e;
                    continue;
                } catch (MQBrokerException e) {
                    endTimestamp = System.currentTimeMillis();
                    this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);
                    log.warn(String.format("sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s", invokeID, endTimestamp - beginTimestampPrev, mq), e);
                    log.warn(msg.toString());
                    exception = e;
                    if (this.defaultMQProducer.getRetryResponseCodes().contains(e.getResponseCode())) {
                        continue;
                    } else {
                        if (sendResult != null) {
                            return sendResult;
                        }

                        throw e;
                    }
                } catch (InterruptedException e) {
                    endTimestamp = System.currentTimeMillis();
                    this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);
                    log.warn(String.format("sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s", invokeID, endTimestamp - beginTimestampPrev, mq), e);
                    log.warn(msg.toString());

                    log.warn("sendKernelImpl exception", e);
                    log.warn(msg.toString());
                    throw e;
                }
            } else {
                break;
            }
        }

        if (sendResult != null) {
            return sendResult;
        }

        String info = String.format("Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s",
                times,
                System.currentTimeMillis() - beginTimestampFirst,
                msg.getTopic(),
                Arrays.toString(brokersSent));

        info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);

        MQClientException mqClientException = new MQClientException(info, exception);
        if (callTimeout) {
            throw new RemotingTooMuchRequestException("sendDefaultImpl call timeout");
        }

        if (exception instanceof MQBrokerException) {
            mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());
        } else if (exception instanceof RemotingConnectException) {
            mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);
        } else if (exception instanceof RemotingTimeoutException) {
            mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);
        } else if (exception instanceof MQClientException) {
            mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);
        }

        throw mqClientException;
    }

    validateNameServerSetting();

    throw new MQClientException("No route info of this topic: " + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);
}
```